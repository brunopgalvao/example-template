//! # Example_template pallet
//! Please, document your pallet properly
//! Learn more about everything related to Polkadot SDK development at <https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/index.html>. Everythin's there!
//! - [`Config`]
//! - [`Call`]
#![cfg_attr(not(feature = "std"), no_std)]

use frame::prelude::*;

use frame::traits::{fungible, VariantCount};

pub mod config_preludes;

use pallet::*;

// A module where the main logic of the pallet is stored
mod pallet_logic;

// A module where the types used in the pallet are stored
mod types;
pub use types::*;

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

#[frame::pallet]
pub mod pallet {
    use super::*;

    /// A reason for the pallet placing a hold on funds.
    #[pallet::composite_enum]
    pub enum HoldReason {
        /// Some hold reason
        #[codec(index = 0)]
        SomeHoldReason,
    }

    #[pallet::pallet]
    pub struct Pallet<T>(_);

    #[pallet::config(with_default)]
    pub trait Config: frame_system::Config {
        /// The aggregated event type of the runtime.
        #[pallet::no_default_bounds]
        type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;

        /// The aggregated origin type of the runtime.
        #[pallet::no_default_bounds]
        type RuntimeOrigin: From<OriginFor<Self>>;

        /// A reason for placing a hold on funds
        #[pallet::no_default_bounds]
        type RuntimeHoldReason: From<HoldReason>;

        /// A reason for placing a freeze on funds
        #[pallet::no_default_bounds]
        type RuntimeFreezeReason: VariantCount;

        /// Type to access the native currency of the blockchain
        #[pallet::no_default]
        type Currency: fungible::Inspect<Self::AccountId>
            + fungible::Mutate<Self::AccountId>
            + fungible::hold::Inspect<Self::AccountId>
            + fungible::hold::Mutate<Self::AccountId, Reason = Self::RuntimeHoldReason>
            + fungible::freeze::Inspect<Self::AccountId>
            + fungible::freeze::Mutate<Self::AccountId>;
    }

    /// A simple StorageValue, storing a u32
    #[pallet::storage]
    pub type MyStorageValue<T: Config> = StorageValue<Value = u32>;

    /// A simple StorageMap, mapping AccountIds with AccountsInfo! Using Twox64Concat as Hasher is Ok cause T::AccountId is generated by a cryptographically secure hash function, so the keys won't create an unbalanced trie.
    #[pallet::storage]
    pub type MyStorageMap<T: Config> =
        StorageMap<Hasher = Twox64Concat, Key = T::AccountId, Value = AccountInfo<T>>;

    #[pallet::event]
    #[pallet::generate_deposit(pub(super) fn deposit_event)]
    pub enum Event<T: Config> {
        /// Someone did something
        SomeoneDidSomething { who: T::AccountId },
    }

    #[pallet::error]
    pub enum Error<T> {
        /// SomethingWentWrong
        SomethingWentWrong,
    }

    #[pallet::genesis_config]
    pub struct GenesisConfig<T: Config> {
        /// This is just an example of genesis configuration
        pub some_genesis_config: BlockNumberFor<T>,
    }

    impl<T: Config> Default for GenesisConfig<T> {
        fn default() -> Self {
            Self {
                some_genesis_config: 1u32.into(),
            }
        }
    }

    #[pallet::genesis_build]
    impl<T: Config> BuildGenesisConfig for GenesisConfig<T> {
        fn build(&self) {
            // TODO: This is just an example, maybe you wanna initialize some storage
        }
    }

    #[pallet::hooks]
    impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
        fn integrity_test() {
            // TODO: Maybe ensure something about your config types...
        }

        #[cfg(feature = "try-runtime")]
        fn try_state(_: BlockNumberFor<T>) -> Result<(), sp_runtime::TryRuntimeError> {
            Self::do_try_state()
        }
    }

    #[pallet::call]
    impl<T: Config> Pallet<T> {}
}
